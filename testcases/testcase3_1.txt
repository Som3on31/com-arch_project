        lw      0       1       mcand           load inputs
        lw      0       2       mplier
        lw      0       6       mulAdr          load mulIni's addr
        jalr    6       7                       CALL FN|jump to mul, saving the return addr to $7
E       noop                                    placeholder lol
stoppu  halt
mulIni  lw      0       6       maxItr          start of multiplication algorithm
        lw      0       4       one
mul     nand    4       2       5               check bits, starting from lsb to msb 
        nand    5       5       5
        beq     5       0       1               check the condition if the lsb is 1                     
        add     1       3       3               UPDATE LOOP|increment here
        add     1       1       1               temp mcand
        add     4       4       4               check the next bit of mplier
        beq     4       6       1               go to jalr below once it is the 32nd iteration
        beq     0       0       mul             go back to the loop otherwise
        jalr    7       0                       return the final value, using $0 here means we are not going to save a return addr
mulAdr  .fill   mulIni                          multiplier addr
mcand   .fill   24
mplier  .fill   45
maxItr  .fill   -2147483648                     a limit of how many iteration is allowed (we use the msb as the limit)
one     .fill   1                               for $4 and lsb check before shifting to the right